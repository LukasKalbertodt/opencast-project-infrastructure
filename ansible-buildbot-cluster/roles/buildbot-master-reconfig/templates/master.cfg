# -*- python -*-
# ex: set filetype=python:

#TOOD: Deploy RPMs and Debs to appropriate repos
#TODO: Workers don't start on buildbot install for some reason
#TODO: Replace call for community members with something like
# curl -L -i -u greg_logan https://api.bitbucket.org/1.0/groups/opencast-community/opencast-committers/members
# Note that the current 2.0 API does not have a way to query this data, so we're using the community list in general instead

from buildbot.plugins import *
import copy
import os.path
import datetime

c = BuildmasterConfig = {}

#The branches you want to configure builders for
#branch is the total git branch name
#pom is the pom version as a string
#dists are the distributions built by this branch
branches = {
  'Develop': {
    'branch': 'develop',
    'pom': '5',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  }, '4.x': {
    'branch': 'r/4.x',
    'pom': '4.0',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  }, '3.x': {
    'branch': 'r/3.x',
    'pom': '3.0',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  },
}

build_lock = util.WorkerLock("worker_builds", maxCount=1)

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
{% for worker in groups['workers'] %}
  worker.Worker("{{ hostvars[worker].id }}", "{{ hostvars[worker].password }}",
                properties={
                  'base': {{ hostvars[worker]['build_base'] }},
                  'site': {{ hostvars[worker]['build_site'] }},
                  'debs': {{ hostvars[worker]['build_debs'] }},
                  'rpms': {{ hostvars[worker]['build_rpms'] }}
                }),
{% endfor %}
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

import requests
def get_community_members():
  r = requests.get("https://bitbucket.org/api/2.0/teams/opencast-community/members")
  data = r.json()
  member_uuids = []
  for user in data['values']:
    member_uuids.append(user['uuid'])
  return member_uuids

def approval_filter(pr, threshold):
  approves = 0
  community = get_community_members()
  for participant in pr['participants']:
    user = participant['user']
    if participant['approved'] and user['uuid'] in community:
      approves = approves + 1

  if approves < threshold:
    return False
  return True

repo = changes.GitPoller(repourl="{{ source_repo_url }}",
                              branches=True,
                              pollinterval=120,
                              buildPushesWithNoCommits=True)

pull_requests = changes.BitbucketPullrequestPoller(
                              owner="{{ source_pr_owner }}",
                              slug="{{ source_pr_slug }}",
                              pollAtLaunch=True,
                              project='pulls',
                              pullrequest_filter=lambda pr : approval_filter(pr,1))


c['change_source'] = [repo, pull_requests]

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

pullScheduler = schedulers.AnyBranchScheduler(name="Pull Requests",
                                                change_filter=util.ChangeFilter(project='pulls'),
                                                treeStableTimer={{ stability_limit }}, #NB: Do not make this a string, a horribly unclear error occurs and nothing works for this scheduler...
                                                builderNames=["Pull Request Build"])

c['schedulers'] = [pullScheduler]

for branchName in branches:
  branch = branches[branchName]
  commits_branch = schedulers.AnyBranchScheduler(name=branchName + " Commits",
                                                  change_filter=util.ChangeFilter(branch_re=branch['branch']),
                                                  treeStableTimer={{ stability_limit }}, #NB: Do not make this a string, a horribly unclear error occurs and nothing works for this scheduler...
                                                  builderNames=[branchName + " Build"])

  nightly_branch = schedulers.Nightly(name=branchName + ' Nightly',
                                     change_filter=util.ChangeFilter(branch_re=branch['branch']),
                                     hour=3, onlyIfChanged=False,
                                     builderNames=[branchName + " Nightly"])

  reports_branch = schedulers.Triggerable(name=branchName + ' Reports',
                                       builderNames=[branchName + " Reports"])

  deb_packaging_branch = schedulers.Triggerable(name=branchName + ' Debian Packaging',
                                       builderNames=[branchName + " Debian Packaging"])

  rpm_packaging_branch = schedulers.Triggerable(name=branchName + ' RPM Packaging',
                                       builderNames=[branchName + " RPM Packaging"])

  forceScheduler = schedulers.ForceScheduler(name="ForceBuildCommits" + branchName[0],
                                           buttonName="Force Build",
                                           label="Force Build Settings",
                                           builderNames=[branchName + " Build", branchName + " Nightly"],

                                           codebases=[
                                               util.CodebaseParameter(
                                                   "",
                                                   label="Main repository",
                                                   # will generate a combo box
                                                   branch=util.FixedParameter(
                                                     name="branch",
                                                     default=branches[branchName]['branch'],
                                                   ),
                                                   # will generate nothing in the form, but revision, repository,
                                                   # and project are needed by buildbot scheduling system so we
                                                   # need to pass a value ("")
                                                   revision=util.FixedParameter(name="revision", default="HEAD"),
                                                   repository=util.FixedParameter(name="repository", default="{{ source_repo_url }}"),
                                                   project=util.FixedParameter(name="project", default=""),
                                               ),
                                           ],

                                           # will generate a text input
                                           reason=util.StringParameter(name="reason", label="Reason:", required=False, size=80, default=""),

                                           # in case you don't require authentication this will display
                                           # input for user to type his name
                                           username=util.UserNameParameter(label="your name:", size=80),
                                           properties=[])

  c['schedulers'].extend([commits_branch, nightly_branch, forceScheduler, reports_branch, deb_packaging_branch, rpm_packaging_branch])


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

checkout = steps.Git(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh',
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout")

prep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=["rm", "-f", ".m2/repository.xml"],
                  flunkOnFailure=False),
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'dependency:go-offline', '-fn'],
                  logfile='deps'),
                util.ShellArg(command=['rm', '-rf', 'build', 'modules/matterhorn-admin-ui-ng/node*', 'modules/admin-ui-ng/node*'],
                  logfile='clean')
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build Prep")

build = steps.ShellCommand(
              command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'clean', 'install', '-Pdist', '-DskipTests'],
              env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build")

uploadTarballs = steps.DirectoryUpload(workersrc="build",
                                       masterdest=util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}")),
                                       url=util.Interpolate(os.path.normpath("{{ artifacts_url }}")), haltOnFailure=True, flunkOnFailure=True, name="Upload build to buildmaster")

reports = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'install'],
                  haltOnFailure=True, flunkOnFailure=True, logfile='build'),
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'cobertura:cobertura', 'site', '-Daggregate=true'],
                  haltOnFailure=True, flunkOnFailure=True, logfile='site')
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build Cobertura and site reports")

clearDeployedReports = steps.MasterShellCommand(command=['rm', '-rf', util.Interpolate(os.path.normpath("{{ deployed_reports }}"))])

uploadReports = steps.DirectoryUpload(workersrc="target/site",
                                       masterdest=util.Interpolate(os.path.normpath("{{ deployed_reports }}")),
                                       url=util.Interpolate(os.path.normpath("{{ reports_url }}")), haltOnFailure=True, flunkOnFailure=True, name="Upload reports to buildmaster")

clean = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'clean', '-fdx'],
                  logfile='git'),
                util.ShellArg(command=['rm', '-rf', 'modules/matterhorn-admin-ui-ng/node*', 'modules/admin-ui-ng/node*'],
                  logfile='node')
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build Prep")

for branchName in branches:
  trigger_reports = steps.Trigger(schedulerNames=[branchName + " Reports"],
                                  waitForFinish=False, name="Trigger " + branchName + " reports",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("revision"),
                                                  "branch" : branches[branchName]['branch'], "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_debs = steps.Trigger(schedulerNames=[branchName + " Debian Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " Debian Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("revision"),
                                                  "branch" : branches[branchName]['branch'], "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_rpms = steps.Trigger(schedulerNames=[branchName + " RPM Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " RPM Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("revision"),
                                                  "branch" : branches[branchName]['branch'], "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  branches[branchName]['triggers'] = {'reports': trigger_reports, 'debs': trigger_debs, 'rpms': trigger_rpms}


debChecker = steps.SetPropertyFromCommand(command="[ -d debs ] && echo True || echo False",
                                          property="alreadyCloned", name="Checking if this is a fresh clone")

def wasCloned(step):
  if step.getProperty("alreadyCloned") == "True":
    return True
  else:
    return False

def wasNotCloned(step):
  return not wasCloned(step)

def hideIfAlreadyCloned(results, step):
  return wasCloned(step)

def hideIfNotAlreadyCloned(results, step):
  return wasNotCloned(step)

debsClone = steps.ShellCommand(
                       command=['git', 'clone', "{{ source_deb_repo_url }}", '--branch', util.Property('branch'), 'debs'],
                         flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasNotCloned, hideStepIf=hideIfAlreadyCloned, name="Cloning debian packaging configs")

debsUpdate = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'fetch'],
                  flunkOnFailure=True, logfile='fetch'),
                util.ShellArg(command=['git', 'reset', '--hard', util.Interpolate('origin/%(prop:branch)s')], #We use reset here to get rid of other entries in the changelog
                  flunkOnFailure=True, logfile='checkout')
              ], workdir="build/debs", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasCloned, hideStepIf=hideIfNotAlreadyCloned, name="Resetting debian packaging configs")

debsVersion = steps.SetPropertyFromCommand(command="git rev-parse HEAD", property="deb_script_rev", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True,
                                   workdir="build/debs", name="Get Debian script revision")

debsClean = steps.ShellCommand(
                       command=['rm', '-rf', 'debs/binaries', 'debs/outputs'], workdir="build/debs",
                       flunkOnFailure=False, warnOnFailure=True, name="Cleaning debian packaging directories")

debsPrep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['dch', '-R', '-D', 'unstable', '-u', 'low', '--empty', util.Interpolate('Build revision %(prop:parent_revision)s, built with %(prop:deb_script_rev)s scripts')], #TODO: Set user for changelog.  Currently root <root@$buildnode>.
                  flunkOnFailure=True, warnOnFailure=True, logfile='dch'),
                util.ShellArg(command=['git', 'config', 'user.email', 'buildbot@opencast.org'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='email'),
                util.ShellArg(command=['git', 'config', 'user.name', 'Buildbot'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='authorname'),
                util.ShellArg(command=['git', 'commit', '-am', 'Automated commit prior to build'])
              ], workdir="build/debs/opencast", name="Prepping Debs")

debsBuild = steps.ShellSequence(
              commands=[
                util.ShellArg(command=util.Interpolate('echo "source library.sh\ndoOpencast %(prop:branch_pretty)s %(prop:branch)s %(prop:parent_revision)s" | tee build.sh'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='write'),
                util.ShellArg(command=['bash', 'build.sh'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='build'),
                util.ShellArg(command=util.Interpolate('echo %(prop:parent_revision)s | tee outputs/%(prop:parent_revision)s/revision.txt'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='revision')
              ], workdir="build/debs", name="Build debs")

debsUpload = steps.DirectoryUpload(workersrc=util.Interpolate("debs/outputs/%(prop:parent_revision)s"),
                                       masterdest=util.Interpolate(os.path.normpath("{{ deployed_debs }}")),
                                       url=util.Interpolate(os.path.normpath("{{ debs_url }}")), haltOnFailure=True, flunkOnFailure=True, name="Uploading debs to buildmaster")

f_pr_build = util.BuildFactory()
f_pr_build.addStep(checkout)
f_pr_build.addStep(prep)
f_pr_build.addStep(build)

def filter_workers(base, site, deb, rpm):
  workers = set()
  for worker in c['workers']:
    if worker.properties['base'] and base:
      workers.add(worker.properties['slavename'])
    if worker.properties['site'] and site:
      workers.add(worker.properties['slavename'])
    if worker.properties['debs'] and deb:
      workers.add(worker.properties['slavename'])
    if worker.properties['rpms'] and rpm:
      workers.add(worker.properties['slavename'])
  return list(workers)

def base_workers():
  return filter_workers(True, False, False, False)

def reporter_workers():
  #NB: A worker which can build reports can also do the normal build
  return filter_workers(True, True, False, False)

def deb_workers():
  return filter_workers(False, False, True, False)

def rpm_workers():
  return filter_workers(False, False, False, True)

def create_branch_builders(branchname):

  f_build = copy.deepcopy(f_pr_build)
  f_build.addStep(steps.SetProperty(property="branch_pretty", value=branchname, name="Set pretty branch name"))
  f_build.addStep(steps.SetPropertyFromCommand(command="date -u +%FT%H-%M-%S", property="build_timestamp",
                                   flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, name="Get build timestamp"))
  f_build.addStep(uploadTarballs)
  f_build.addStep(clean)

  f_reports = util.BuildFactory()
  f_reports.addStep(checkout)
  f_reports.addStep(prep)
  f_reports.addStep(reports)
  f_reports.addStep(clearDeployedReports)
  f_reports.addStep(uploadReports)
  f_reports.addStep(clean)

  #We have some branch-specific steps that have to be built or fetched, do that first
  report_trigger_step = branches[branchname]['triggers']['reports']
  deb_trigger_step = branches[branchname]['triggers']['debs']
  rpm_trigger_step = branches[branchname]['triggers']['rpms']

  f_full_build = copy.deepcopy(f_build)
  f_full_build.addStep(report_trigger_step)
  f_full_build.addStep(deb_trigger_step)
  f_full_build.addStep(rpm_trigger_step)
  f_full_build.addStep(clean)

  f_package_debs = util.BuildFactory()
  f_package_debs.addStep(debChecker)
  f_package_debs.addStep(debsClone)
  f_package_debs.addStep(debsUpdate)
  f_package_debs.addStep(debsVersion)
  #Fetch artifacts
  branch = branches[branchname]
  for dist in branch['dists']:
    filename = "opencast-dist-" + dist + "-" + branch['pom'] + "-SNAPSHOT.tar.gz"
    f_package_debs.addStep(steps.FileDownload(mastersrc=util.Interpolate(os.path.join("{{ parent_dist_base }}/", filename)),
                             workerdest=util.Interpolate(os.path.join("debs/binaries/%(prop:branch_pretty)s/", filename)), name="Fetch " + filename))
  f_package_debs.addStep(debsPrep)
  f_package_debs.addStep(debsBuild)
  f_package_debs.addStep(debsUpload)
  f_package_debs.addStep(clean)

  f_package_rpms = util.BuildFactory()
  #TODO: Add steps to build the RPMs


  b_build = util.BuilderConfig(name=branchname + " Build",
        workernames=base_workers(), locks=[build_lock.access('counting')],
        factory=f_build, collapseRequests=True)

  b_nightly = util.BuilderConfig(name=branchname + " Nightly",
        workernames=base_workers(), locks=[build_lock.access('counting')],
        factory=f_full_build, collapseRequests=True)

  b_reports = util.BuilderConfig(name=branchname + " Reports",
        workernames=reporter_workers(), locks=[build_lock.access('counting')],
        factory=f_reports, collapseRequests=True)

  b_package_debs = util.BuilderConfig(name=branchname + " Debian Packaging",
        workernames=deb_workers(), locks=[build_lock.access('counting')],
        factory=f_package_debs, collapseRequests=True)

  b_package_rpms = util.BuilderConfig(name=branchname + " RPM Packaging",
        workernames=rpm_workers(), locks=[build_lock.access('counting')],
        factory=f_package_rpms, collapseRequests=True)

  return [ b_build, b_nightly, b_reports, b_package_debs, b_package_rpms ]


b_pr = util.BuilderConfig(name="Pull Request Build",
      workernames=base_workers(), locks=[build_lock.access('counting')],
      factory=f_pr_build, collapseRequests=True)

c['builders'] = [ b_pr ]
for branch in branches.keys():
  c['builders'].extend(create_branch_builders(branch))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

irc = reporters.IRC("irc.freenode.net", "oc-buildbot",
                 channels=["#opencast"],
                 allowForce=False,
                 allowShutdown=False,
                 notify_events={
                   'exception': 1,
                   'successToFailure': 1,
                   'failureToSuccess': 1,
                 })

{% raw %}
template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
<p> Build link <a href="{{ build_url }}">here</a>
<p><b> -- The Buildbot</b></p>
'''
{% endraw %}

mn = reporters.MailNotifier(fromaddr="buildbot@opencast.org",
                            sendToInterestedUsers=False,
                            mode=('change', 'failing', 'problem', 'warnings', 'exception'),
                            extraRecipients=["{{ mail_to }}"],
                            messageFormatter=reporters.MessageFormatter(
                                template=template, template_type='html',
                                wantProperties=True, wantSteps=True))

bs = reporters.BitbucketStatusPush("{{ bitbucket_oath_client_id }}", "{{ bitbucket_oath_client_secret }}",
                                   builders=[b_pr])

#IRC bot has no auth, and basic things cause massive stack traces :(
c['services'] = [mn, bs]#, irc]

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Opencast"
c['titleURL'] = "https://bitbucket.org/opencast-community/opencast.git"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://{{ inventory_hostname }}/{{buildbot_url}}"

# minimalistic config to activate new web UI
c['www'] = dict(port={{ buildbot_port }},
                plugins=dict(waterfall_view={}, console_view={}),
                auth=util.BitbucketAuth("{{ bitbucket_oath_client_id }}", "{{ bitbucket_oath_client_secret }}"),
                authz=util.Authz(
                        allowRules=[
                            util.AnyControlEndpointMatcher(role="committers")
                        ],
                        roleMatchers=[
                            #This is not possible as implemented right now.  The BitbucketAuth plugin
                            #only uses the 2.0 API, which does not have a way to get the user's groups :(
                            #util.RolesFromGroups(groupPrefix='opencast-'),
                            util.RolesFromUsername(roles=["committers"], usernames=["greg_logan", "lkiesow"])
                        ]
                      )
                )

c['logCompressionMethod'] = 'gz'
#Don't set the settings below - they lead to log truncation
#c['logMaxSize'] = 1024*1024 # 1M
#c['logMaxTailSize'] = 32768
c['logEncoding'] = 'utf-8'
#Turn off usage data collection
c['buildbotNetUsageData'] = None

#Clean up the database - note that this does *not* clean up the filesystem!
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=datetime.timedelta(weeks=4),
    hour=12,
    dayOfWeek=6
)]

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
