# -*- python -*-
# ex: set filetype=python:

#TODO: Set up classes of workers so that reports only build on high-RAM workers, and packaging only builds on approriate packaging nodes
#TODO: Set up user auth so that people can look but not touch
#TODO: Deploy reports somewhere useful
#TODO: Deploy failed unit test reports somewhere useful
#TOOD: Deploy RPMs and Debs to appropriate repos
#TODO: Change buildbot url setting to port 80?  Or figure out how to reverse proxy in front of it
#TODO: Reenable IRC reporter
#TODO: Enable mail reporter
#TODO: Break this file up into sectional-files

from buildbot.plugins import *
import copy

c = BuildmasterConfig = {}

#The branches you want to configure builders for
#branch is the total git branch name
#pom is the pom version as a string
#dists are the distributions built by this branch
branches = {
  'Develop': {
    'branch': 'develop',
    'pom': '5',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  }, '4.x': {
    'branch': 'r/4.x',
    'pom': '4.0',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  }, '3.x': {
    'branch': 'r/3.x',
    'pom': '3.0',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  },
}

buildUrl = "/builds"
buildDest = '/var/www/buildbot/%(prop:branch)s/%(prop:buildnumber)s'

build_lock = util.WorkerLock("worker_builds", maxCount=1)

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
{% for worker in groups['workers'] %}
  worker.Worker("{{ hostvars[worker].inventory_hostname }}", "{{ hostvars[worker].password }}"),
{% endfor %}
]

worker_names = [
{% for worker in groups['workers'] %}
  "{{ hostvars[worker].inventory_hostname }}",
{% endfor %}
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

import requests
def get_community_members():
  r = requests.get("https://bitbucket.org/api/2.0/teams/opencast-community/members")
  data = r.json()
  member_uuids = []
  for user in data['values']:
    member_uuids.append(user['uuid'])
  return member_uuids

def approval_filter(pr, threshold):
  approves = 0
  community = get_community_members()
  for participant in pr['participants']:
    user = participant['user']
    if participant['approved'] and user['uuid'] in community:
      approves = approves + 1

  if approves < threshold:
    return False
  return True

upstream = changes.GitPoller(repourl="https://bitbucket.org/opencast-community/opencast.git",
                              branches=True,
                              pollinterval=120,
                              buildPushesWithNoCommits=True)

upstream_pull_requests = changes.BitbucketPullrequestPoller(
                              owner="opencast-community",
                              slug="opencast",
                              pollAtLaunch=True,
                              project='pulls',
                              pullrequest_filter=lambda pr : approval_filter(pr,1))

mine = changes.GitPoller(repourl="https://bitbucket.org/greg_logan/matterhorn.git",
                              branches=True,
                              pollinterval=30, #120,
                              buildPushesWithNoCommits=True)

pull_requests = changes.BitbucketPullrequestPoller(
                              owner="greg_logan",
                              slug="matterhorn",
                              pollAtLaunch=True,
                              project='pulls',
                              pullrequest_filter=lambda pr : approval_filter(pr,1))


c['change_source'] = [mine] #, pull_requests, upstream, upstream_pull_requests]

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

pullScheduler = schedulers.AnyBranchScheduler(name="Pull Requests",
                                                change_filter=util.ChangeFilter(project='pulls'),
                                                treeStableTimer=5, #300, GDLGDL
                                                builderNames=["Pull Request Build"])


c['schedulers'] = [pullScheduler]

for branchName in branches:
  branch = branches[branchName]
  commits_branch = schedulers.AnyBranchScheduler(name=branchName + " Commits",
                                                  change_filter=util.ChangeFilter(branch_re=branch['branch']),
                                                  treeStableTimer=5, #300, GDLGDL
                                                  builderNames=[branchName + " Build"])

  nightly_branch = schedulers.Nightly(name=branchName + ' Nightly',
                                     change_filter=util.ChangeFilter(branch_re=branch['branch']),
                                     hour=3, onlyIfChanged=True,
                                     builderNames=[branchName + " Nightly"])

  reports_branch = schedulers.Triggerable(name=branchName + ' Reports',
                                       builderNames=[branchName + " Reports"])

  deb_packaging_branch = schedulers.Triggerable(name=branchName + ' Debian Packaging',
                                       builderNames=[branchName + " Debian Packaging"])

  rpm_packaging_branch = schedulers.Triggerable(name=branchName + ' RPM Packaging',
                                       builderNames=[branchName + " RPM Packaging"])

  c['schedulers'].extend([commits_branch, nightly_branch, reports_branch, deb_packaging_branch, rpm_packaging_branch])

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

checkout = steps.Git(repourl=util.Property('repository'),
                     mode='incremental', method='fresh',
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout")

prep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=["rm", "-f", ".m2/repository.xml"],
                  flunkOnFailure=False),
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'dependency:go-offline', '-fn'],
                  logfile='deps'),
                util.ShellArg(command=['rm', '-rf', 'build', 'modules/matterhorn-admin-ui-ng/node*', 'modules/admin-ui-ng/node*'],
                  logfile='clean')
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build Prep")

build = steps.ShellCommand(
              command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'clean', 'install', '-Pdist', '-DskipTests'],
              env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build")

uploadTarballs = steps.DirectoryUpload(workersrc="build",
                                       masterdest=util.Interpolate(buildDest),
                                       url=buildUrl, haltOnFailure=True, flunkOnFailure=True, name="Upload build to buildmaster")

reports = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'install', 'cobertura:cobertura', 'site', '-Daggregate=true', '-Pdist'],
                  flunkOnFailure=True, logfile='site'),
                util.ShellArg(command=['tar', 'cvjf', 'build/site.tar.bz2', 'target/site'],
                  logfile='site_compress')
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build Cobertura and site reports")

uploadReports = steps.DirectoryUpload(workersrc="build/site.tar.bz2",
                                       masterdest=util.Interpolate(buildDest),
                                       url=buildUrl, haltOnFailure=True, flunkOnFailure=True, name="Upload reports to buildmaster")

for branchName in branches:
  trigger_reports = steps.Trigger(schedulerNames=[branchName + " Reports"],
                                  waitForFinish=False, name="Trigger " + branchName + " reports",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("revision")})

  trigger_debs = steps.Trigger(schedulerNames=[branchName + " Debian Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " Debian Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("revision")})

  trigger_rpms = steps.Trigger(schedulerNames=[branchName + " RPM Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " RPM Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("revision")})

  branches[branchName]['triggers'] = {'reports': trigger_reports, 'debs': trigger_debs, 'rpms': trigger_rpms}


debChecker = steps.SetPropertyFromCommand(command="[ -d debs ] && echo True || echo False",
                                          property="alreadyCloned", name="Checking if this is a fresh clone")

def wasCloned(step):
  if step.getProperty("alreadyCloned") == "True":
    return True
  else:
    return False

def wasNotCloned(step):
  return not wasCloned(step)

def hideIfAlreadyCloned(results, step):
  return wasCloned(step)

def hideIfNotAlreadyCloned(results, step):
  return wasNotCloned(step)

debsClone = steps.ShellCommand(
                       command=['git', 'clone', 'git@bitbucket.org:greg_logan/debian_packaging-private.git', '--branch', util.Property('branch'), 'debs'],
                         flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasNotCloned, hideStepIf=hideIfAlreadyCloned, name="Cloning debian packaging configs")

debsUpdate = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'fetch'],
                  flunkOnFailure=True, logfile='fetch'),
                util.ShellArg(command=['git', 'reset', '--hard', util.Interpolate('origin/%(prop:branch)s')], #We use reset here to get rid of other entries in the changelog
                  flunkOnFailure=True, logfile='checkout')
              ], workdir="build/debs", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasCloned, hideStepIf=hideIfNotAlreadyCloned, name="Resetting debian packaging configs")

debsVersion = steps.SetPropertyFromCommand(command="git rev-parse HEAD", property="deb_script_rev", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True,
                                   workdir="build/debs", name="Get Debian script revision")

debsClean = steps.ShellCommand(
                       command=['rm', '-rf', 'debs/binaries', 'debs/outputs'], workdir="build/debs",
                       flunkOnFailure=False, warnOnFailure=True, name="Cleaning debian packaging directories")

def generateFetchSteps(branchname):
  fetches = []
  branch = branches[branchname]
  fetches.append(steps.SetProperty(property="debs_branch_pretty", value=branchname, name="Set Debs pretty name"))
  for dist in branch['dists']:
    filename = "opencast-dist-" + dist + "-" + branch['pom'] + "-SNAPSHOT.tar.gz"
    fetches.append(steps.FileDownload(mastersrc=util.Interpolate('/var/www/buildbot/%(prop:branch)s/%(prop:parent_build)s' + "/" + filename),
                             workerdest=util.Interpolate("debs/binaries/%(prop:debs_branch_pretty)s/" + filename), name="Fetch " + filename))
  return fetches

debsPrep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['dch', '-R', '-D', 'unstable', '-u', 'low', '--empty', util.Interpolate('Build revision %(prop:parent_revision)s, built with %(prop:deb_script_rev)s scripts')], #TODO: Set user for changelog.  Currently root <root@$buildnode>.
                  flunkOnFailure=True, warnOnFailure=True, logfile='dch'),
                util.ShellArg(command=['git', 'config', 'user.email', 'buildbot@opencast.org'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='email'),
                util.ShellArg(command=['git', 'config', 'user.name', 'Buildbot'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='authorname'),
                util.ShellArg(command=['git', 'commit', '-am', 'Automated commit prior to build'])
              ], workdir="build/debs/opencast", name="Prepping Debs")

debsBuild = steps.ShellSequence(
              commands=[
                util.ShellArg(command=util.Interpolate('echo "source library.sh\ndoOpencast %(prop:debs_branch_pretty)s %(prop:branch)s %(prop:parent_revision)s" | tee build.sh'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='write'),
                util.ShellArg(command=['bash', 'build.sh'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='build'),
                util.ShellArg(command=util.Interpolate('echo %(prop:parent_revision)s | tee outputs/%(prop:parent_revision)s/revision.txt'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='revision')
              ], workdir="build/debs", name="Build debs")

debsUpload = steps.DirectoryUpload(workersrc=util.Interpolate("debs/outputs/%(prop:parent_revision)s"),
                                       masterdest=util.Interpolate('/var/www/buildbot/%(prop:debs_branch_pretty)s/%(prop:parent_build)s'),
                                       url=buildUrl, haltOnFailure=True, flunkOnFailure=True, name="Uploading debs to buildmaster")

f_pr_build = util.BuildFactory()
f_pr_build.addStep(checkout)
f_pr_build.addStep(prep)
f_pr_build.addStep(build)

f_build = copy.deepcopy(f_pr_build)
f_build.addStep(uploadTarballs)

f_reports = util.BuildFactory()
f_reports.addStep(checkout)
f_reports.addStep(prep)
f_reports.addStep(reports)
f_reports.addStep(uploadReports)


def create_branch_builders(branchname):

  #We have some branch-specific steps that have to be built or fetched, do that first
  report_trigger_step = branches[branchname]['triggers']['reports']
  deb_trigger_step = branches[branchname]['triggers']['debs']
  rpm_trigger_step = branches[branchname]['triggers']['rpms']

  f_full_build = copy.deepcopy(f_build)
  f_full_build.addStep(report_trigger_step)
  f_full_build.addStep(deb_trigger_step)
  f_full_build.addStep(rpm_trigger_step)

  f_package_debs = util.BuildFactory()
  f_package_debs.addStep(debChecker)
  f_package_debs.addStep(debsClone)
  f_package_debs.addStep(debsUpdate)
  f_package_debs.addStep(debsVersion)
  #Fetch artifacts
  for step in generateFetchSteps(branchname):
    f_package_debs.addStep(step)
  f_package_debs.addStep(debsPrep)
  f_package_debs.addStep(debsBuild)
  f_package_debs.addStep(debsUpload)

  f_package_rpms = util.BuildFactory()
  #TODO: Add steps to build the RPMs


  b_build = util.BuilderConfig(name=branchname + " Build",
        workernames=worker_names, locks=[build_lock.access('counting')],
#        factory=f_build, collapseRequests=True)
        factory=f_full_build, collapseRequests=True)

  b_nightly = util.BuilderConfig(name=branchname + " Nightly",
        workernames=worker_names, locks=[build_lock.access('counting')],
        factory=f_full_build, collapseRequests=True)

  b_reports = util.BuilderConfig(name=branchname + " Reports",
        workernames=worker_names, locks=[build_lock.access('counting')],
        factory=f_reports, collapseRequests=True)

  b_package_debs = util.BuilderConfig(name=branchname + " Debian Packaging",
        workernames=worker_names, locks=[build_lock.access('counting')],
        factory=f_package_debs, collapseRequests=True)

  b_package_rpms = util.BuilderConfig(name=branchname + " RPM Packaging",
        workernames=worker_names, locks=[build_lock.access('counting')],
        factory=f_package_rpms, collapseRequests=True)

  return [ b_build, b_nightly, b_reports, b_package_debs, b_package_rpms ]


b_build = util.BuilderConfig(name="Pull Request Build",
      workernames=worker_names, locks=[build_lock.access('counting')],
      factory=f_pr_build, collapseRequests=True)

c['builders'] = [ b_build ]
for branch in branches.keys():
  c['builders'].extend(create_branch_builders(branch))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

irc = reporters.IRC("irc.freenode.net", "oc-buildbot",
                 channels=["#opencast"],
                 notify_events={
                   'exception': 1,
                   'successToFailure': 1,
                   'failureToSuccess': 1,
                 })

{% raw %}
template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
{% for step in build['steps'] %}
<p> {{ step['name'] }}: {{ step['result'] }}</p>
{% endfor %}
<p><b> -- The Buildbot</b></p>
'''
{% endraw %}

mn = reporters.MailNotifier(fromaddr="buildbot@opencast.org",
                            sendToInterestedUsers=False,
                            mode=('change', 'failing', 'problem', 'warnings', 'exception'),
                            extraRecipients=['dev@opencast.org'],
                            messageFormatter=reporters.MessageFormatter(
                                template=template, template_type='html',
                                wantProperties=True, wantSteps=True))

c['services'] = []#mn, irc]

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Opencast"
c['titleURL'] = "https://bitbucket.org/opencast-community/opencast.git"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://{{ inventory_hostname }}:8010/"

# minimalistic config to activate new web UI
c['www'] = dict(port=8010,
                plugins=dict(waterfall_view={}, console_view={}))

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
