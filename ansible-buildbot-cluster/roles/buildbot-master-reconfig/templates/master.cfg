# -*- python -*-
# ex: set filetype=python:

#TOOD: Deploy RPMs and Debs to appropriate repos

from buildbot.plugins import *
import copy
import os.path
import datetime

c = BuildmasterConfig = {}

#The branches you want to configure builders for
#branch is the total git branch name
#pom is the pom version as a string
#dists are the distributions built by this branch
branches = {
  'Develop': {
    'branch': 'develop',
    'pom': '5',
    'debsVersion': '5.x',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  }, '4.x': {
    'branch': 'r/4.x',
    'pom': '4.0',
    'debsVersion': '4.x',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  }, '3.x': {
    'branch': 'r/3.x',
    'pom': '3.0',
    'debsVersion': '3.x',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  },
}

build_lock = util.WorkerLock("worker_builds", maxCount=1)

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
{% for worker in groups['workers'] %}
  worker.Worker("{{ hostvars[worker].id }}", "{{ hostvars[worker].password }}",
                properties={
                  'base': {{ hostvars[worker]['build_base'] }},
                  'site': {{ hostvars[worker]['build_site'] }},
                  'debs': {{ hostvars[worker]['build_debs'] }},
                  'rpms': {{ hostvars[worker]['build_rpms'] }}
                }),
{% endfor %}
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

repo = changes.GitPoller(repourl="{{ source_repo_url }}",
                              branches=True,
                              pollinterval={{ poll_interval }},
                              buildPushesWithNoCommits=True)

pull_requests = changes.GitHubPullrequestPoller(
                              owner="{{ source_pr_owner }}",
                              repo="{{ source_pr_slug }}",
                              pollAtLaunch=True,
                              pollInterval={{ poll_interval }},
                              repository_type="git",
                              token="{{ github_token }}",
                              magic_link=True)
# This is only for personal, would need a machine acct                              token=,


#Disabled for testing webhook
c['change_source'] = [] #[repo, pull_requests]

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

pullScheduler = schedulers.AnyBranchScheduler(name="Pull Requests",
                                                treeStableTimer={{ stability_limit }}, #NB: Do not make this a string, a horribly unclear error occurs and nothing works for this scheduler...
                                                builderNames=["Pull Request Build"],
                                                change_filter=util.ChangeFilter(category="pull"))

c['schedulers'] = [pullScheduler]

for branchName in branches:
  branch = branches[branchName]
  commits_branch = schedulers.AnyBranchScheduler(name=branchName + " Commits",
                                                  change_filter=util.ChangeFilter(category=None, branch_re=branch['branch']),
                                                  treeStableTimer={{ stability_limit }}, #NB: Do not make this a string, a horribly unclear error occurs and nothing works for this scheduler...
                                                  builderNames=[branchName + " Build"])

  nightly_branch = schedulers.Nightly(name=branchName + ' Nightly',
                                     change_filter=util.ChangeFilter(category=None, branch_re=branch['branch']),
                                     hour=3, onlyIfChanged=False,
                                     builderNames=[branchName + " Nightly"])

  reports_branch = schedulers.Triggerable(name=branchName + ' Reports',
                                       builderNames=[branchName + " Reports"])

  deb_packaging_branch = schedulers.Triggerable(name=branchName + ' Debian Packaging',
                                       builderNames=[branchName + " Debian Packaging"])

  rpm_packaging_branch = schedulers.Triggerable(name=branchName + ' RPM Packaging',
                                       builderNames=[branchName + " RPM Packaging"])

  forceScheduler = schedulers.ForceScheduler(name="ForceBuildCommits" + branchName[0],
                                           buttonName="Force Build",
                                           label="Force Build Settings",
                                           builderNames=[branchName + " Build", branchName + " Nightly"],

                                           codebases=[
                                               util.CodebaseParameter(
                                                   "",
                                                   label="Main repository",
                                                   # will generate a combo box
                                                   branch=util.FixedParameter(
                                                     name="branch",
                                                     default=branches[branchName]['branch'],
                                                   ),
                                                   # will generate nothing in the form, but revision, repository,
                                                   # and project are needed by buildbot scheduling system so we
                                                   # need to pass a value ("")
                                                   revision=util.FixedParameter(name="revision", default="HEAD"),
                                                   repository=util.FixedParameter(name="repository", default="{{ source_repo_url }}"),
                                                   project=util.FixedParameter(name="project", default=""),
                                               ),
                                           ],

                                           # will generate a text input
                                           reason=util.StringParameter(name="reason", label="Reason:", required=False, size=80, default=""),

                                           # in case you don't require authentication this will display
                                           # input for user to type his name
                                           username=util.UserNameParameter(label="your name:", size=80),
                                           properties=[])

  c['schedulers'].extend([commits_branch, nightly_branch, forceScheduler, reports_branch, deb_packaging_branch, rpm_packaging_branch])


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

checkout = steps.GitHub(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh',
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout")

prep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=["rm", "-f", ".m2/repository.xml"],
                  flunkOnFailure=False),
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'dependency:go-offline', '-fn'],
                  logfile='deps'),
                util.ShellArg(command=['git', 'clean', '-fdx'],
                  logfile='clean')
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build Prep")

build = steps.ShellCommand(
              command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'clean', 'install'],
              env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build")

prep_master = steps.MasterShellCommand(
                     command=['mkdir', '-p',
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}")),
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}/reports")),
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}/debs")),
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}/rpms")),
                       util.Interpolate(os.path.normpath("{{ deployed_reports_symlink_base }}"))],
                     name="Prep relevant directories on buildmaster")

prep_PR_master = steps.MasterShellCommand(
                     command=['mkdir', '-p',
                       util.Interpolate(os.path.normpath("{{ deployed_PR_coverage }}"))],
                     name="Prep relevant directories on buildmaster")

#Note: We're using a string here because using the array disables shell globbing!  This applies to the scp steps as well.
uploadTarballs = steps.ShellCommand(
                        command=util.Interpolate("scp build/*.tar.gz {{ buildbot_scp_builds_put }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload build to buildmaster")

cobertura = steps.ShellCommand(
                command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'cobertura:cobertura'],
                env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
                haltOnFailure=True, flunkOnFailure=True, name="Build Cobertura report")

uploadCobertura = steps.ShellCommand(
                        command=util.Interpolate("scp -r target/site/cobertura {{ buildbot_scp_coverage }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload code coverage report to buildmaster")

uploadPRCobertura = steps.ShellCommand(
                        command=util.Interpolate("scp -r target/site/cobertura {{ buildbot_scp_PR_coverage }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload code coverage report to buildmaster")

site = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'install'],
                  logfile='build', flunkOnFailure=True, haltOnFailure=True),
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', 'site', '-Daggregate=true'],
                  logfile='site', flunkOnFailure=True, haltOnFailure=True)
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Build site report")

uploadSite = steps.ShellCommand(
                        command=util.Interpolate("scp -r target/site/* {{ buildbot_scp_reports }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload site report to buildmaster")

#Updating the symlink
updateSite = steps.MasterShellCommand(
                       command=util.Interpolate("rm -f {{ deployed_reports_symlink }} && ln -s {{ deployed_reports }} {{ deployed_reports_symlink }}"),
                       name="Deploy Reports")

clean = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'clean', '-fdx'],
                  logfile='git'),
                util.ShellArg(command=['rm', '-rf', 'modules/matterhorn-admin-ui-ng/node*', 'modules/admin-ui-ng/node*'],
                  logfile='node')
              ], env={'JAVA_HOME': '/usr/lib/jvm/java-8-openjdk-amd64'},
              haltOnFailure=True, flunkOnFailure=True, name="Cleanup")

for branchName in branches:
  trigger_reports = steps.Trigger(schedulerNames=[branchName + " Reports"],
                                  waitForFinish=False, name="Trigger " + branchName + " reports",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_debs = steps.Trigger(schedulerNames=[branchName + " Debian Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " Debian Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_rpms = steps.Trigger(schedulerNames=[branchName + " RPM Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " RPM Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  branches[branchName]['triggers'] = {'reports': trigger_reports, 'debs': trigger_debs, 'rpms': trigger_rpms}


debChecker = steps.SetPropertyFromCommand(command="[ -d .git ] && echo True || echo False",
                                          property="alreadyCloned", name="Checking if this is a fresh clone")

def wasCloned(step):
  if step.getProperty("alreadyCloned") == "True":
    return True
  else:
    return False

def wasNotCloned(step):
  return not wasCloned(step)

def hideIfAlreadyCloned(results, step):
  return wasCloned(step)

def hideIfNotAlreadyCloned(results, step):
  return wasNotCloned(step)

debsClone = steps.ShellCommand(
                       command=['git', 'clone', "{{ source_deb_repo_url }}", '--branch', util.Property('branch'), './'],
                         flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasNotCloned, hideStepIf=hideIfAlreadyCloned, name="Cloning debian packaging configs")

debsUpdate = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'fetch'],
                  flunkOnFailure=True, logfile='fetch'),
                util.ShellArg(command=['git', 'reset', '--hard', util.Interpolate('origin/%(prop:branch)s')], #We use reset here to get rid of other entries in the changelog
                  flunkOnFailure=True, logfile='checkout')
              ], workdir="build", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasCloned, hideStepIf=hideIfNotAlreadyCloned, name="Resetting debian packaging configs")

debsVersion = steps.SetPropertyFromCommand(command="git rev-parse HEAD", property="deb_script_rev", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True,
                                   workdir="build", name="Get Debian script revision")

debsClean = steps.ShellCommand(
                       command=['rm', '-rf', 'binaries', 'outputs'], workdir="build",
                       flunkOnFailure=False, warnOnFailure=True, name="Cleaning debian packaging directories")

debsPrep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['dch', '--newversion', util.Interpolate('%(prop:debs_package_version)s-%(prop:parent_build)s'), '-b', '-D', 'unstable', '-u', 'low', '--empty', util.Interpolate('Build revision %(prop:parent_revision)s, built with %(prop:deb_script_rev)s scripts')],
                  flunkOnFailure=True, warnOnFailure=True, logfile='dch'),
                util.ShellArg(command=['git', 'config', 'user.email', 'buildbot@opencast.org'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='email'),
                util.ShellArg(command=['git', 'config', 'user.name', 'Buildbot'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='authorname'),
                util.ShellArg(command=['git', 'commit', '-am', 'Automated commit prior to build'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='commit')
              ], workdir="build/opencast", name="Prepping Debs", haltOnFailure=True, flunkOnFailure=True)

debsFetch = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['mkdir', '-p', util.Interpolate('binaries/%(prop:debs_package_version)s')],
                  haltOnFailure=True, flunkOnFailure=True, logfile="prep"),
                util.ShellArg(command=util.Interpolate("scp {{ buildbot_scp_builds_get }} binaries/%(prop:debs_package_version)s/"),
                  haltOnFailure=True, flunkOnFailure=True, logfile="download")
              ], name="Fetching built artifacts from buildmaster", haltOnFailure=True, flunkOnFailure=True)


debsBuild = steps.ShellSequence(
              commands=[
                util.ShellArg(command=util.Interpolate('echo "source library.sh\ndoOpencast %(prop:debs_package_version)s %(prop:branch)s %(prop:parent_revision)s" | tee build.sh'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='write'),
                util.ShellArg(command=['bash', 'build.sh'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='build'),
                util.ShellArg(command=util.Interpolate('echo %(prop:parent_revision)s | tee outputs/%(prop:parent_revision)s/revision.txt'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='revision')
              ], workdir="build", name="Build debs", haltOnFailure=True, flunkOnFailure=True)

debsUpload = steps.ShellCommand(
                        command=util.Interpolate("scp -r outputs/%(prop:parent_revision)s/* {{ buildbot_scp_debs }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload debs to buildmaster")


f_pr_build = util.BuildFactory()
f_pr_build.addStep(checkout)
f_pr_build.addStep(prep)
f_pr_build.addStep(build)
f_pr_build.addStep(cobertura)
f_pr_build.addStep(prep_PR_master)
f_pr_build.addStep(uploadPRCobertura)

def filter_workers(base, site, deb, rpm):
  workers = set()
  for worker in c['workers']:
    if worker.properties['base'] and base:
      workers.add(worker.properties['slavename'])
    if worker.properties['site'] and site:
      workers.add(worker.properties['slavename'])
    if worker.properties['debs'] and deb:
      workers.add(worker.properties['slavename'])
    if worker.properties['rpms'] and rpm:
      workers.add(worker.properties['slavename'])
  return list(workers)

def base_workers():
  return filter_workers(True, False, False, False)

def reporter_workers():
  #NB: A worker which can build reports can also do the normal build
  return filter_workers(True, True, False, False)

def deb_workers():
  return filter_workers(False, False, True, False)

def rpm_workers():
  return filter_workers(False, False, False, True)

def create_branch_builders(branchname):

  f_build = util.BuildFactory()
  #This is needed because the nightly schedulers don't set the branch name for some reason...
  f_build.addStep(steps.SetProperty(property="branch", value=branches[branchname]['branch'], name="Set regular branch name"))
  f_build.addStep(steps.SetProperty(property="branch_pretty", value=branchname, name="Set pretty branch name"))
  f_build.addStep(steps.SetPropertyFromCommand(command="date -u +%FT%H-%M-%S", property="build_timestamp",
                                   flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, name="Get build timestamp"))
  f_build.addStep(steps.Git(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh', branch=branches[branchname]['branch'],
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout"))
  f_build.addStep(prep)
  f_build.addStep(build)
  f_build.addStep(cobertura)
  f_build.addStep(prep_master)
  f_build.addStep(uploadTarballs)
  f_build.addStep(uploadCobertura)
  f_build.addStep(clean)

  f_reports = util.BuildFactory()
  f_reports.addStep(steps.Git(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh', branch=branches[branchname]['branch'],
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout"))
  f_reports.addStep(prep)
  f_reports.addStep(site)
  f_reports.addStep(uploadSite)
  f_reports.addStep(updateSite)
  f_reports.addStep(clean)

  #We have some branch-specific steps that have to be built or fetched, do that first
  report_trigger_step = branches[branchname]['triggers']['reports']
  deb_trigger_step = branches[branchname]['triggers']['debs']
  rpm_trigger_step = branches[branchname]['triggers']['rpms']

  f_full_build = copy.deepcopy(f_build)
  f_full_build.addStep(report_trigger_step)
  f_full_build.addStep(deb_trigger_step)
  f_full_build.addStep(rpm_trigger_step)

  f_package_debs = util.BuildFactory()
  f_package_debs.addStep(steps.SetProperty(property="branch", value=branches[branchname]['branch'], name="Set regular branch name"))
  f_package_debs.addStep(steps.SetProperty(property="branch_pretty", value=branchname, name="Set pretty branch name"))
  f_package_debs.addStep(steps.SetProperty(property="debs_package_version", value=branches[branchname]['debsVersion'], name="Set Debian package version"))
  f_package_debs.addStep(debChecker)
  f_package_debs.addStep(debsClone)
  f_package_debs.addStep(debsUpdate)
  f_package_debs.addStep(debsVersion)
  f_package_debs.addStep(debsPrep)
  f_package_debs.addStep(debsFetch)
  f_package_debs.addStep(debsBuild)
  f_package_debs.addStep(debsUpload)
  f_package_debs.addStep(clean)

  f_package_rpms = util.BuildFactory()
  #TODO: Add steps to build the RPMs


  b_build = util.BuilderConfig(name=branchname + " Build",
        workernames=base_workers(), locks=[build_lock.access('counting')],
        factory=f_build, collapseRequests=True)

  b_nightly = util.BuilderConfig(name=branchname + " Nightly",
        workernames=base_workers(), locks=[build_lock.access('counting')],
        factory=f_full_build, collapseRequests=True)

  b_reports = util.BuilderConfig(name=branchname + " Reports",
        workernames=reporter_workers(), locks=[build_lock.access('counting')],
        factory=f_reports, collapseRequests=True)

  b_package_debs = util.BuilderConfig(name=branchname + " Debian Packaging",
        workernames=deb_workers(), locks=[build_lock.access('counting')],
        factory=f_package_debs, collapseRequests=True)

  b_package_rpms = util.BuilderConfig(name=branchname + " RPM Packaging",
        workernames=rpm_workers(), locks=[build_lock.access('counting')],
        factory=f_package_rpms, collapseRequests=True)

  return [ b_build, b_nightly, b_reports, b_package_debs, b_package_rpms ]


b_pr = util.BuilderConfig(name="Pull Request Build",
      workernames=base_workers(), locks=[build_lock.access('counting')],
      factory=f_pr_build, collapseRequests=True)

c['builders'] = [ b_pr ]
for branch in branches.keys():
  c['builders'].extend(create_branch_builders(branch))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

irc = reporters.IRC("irc.freenode.net", "oc-buildbot",
                 channels=["#opencast"],
                 allowForce=False,
                 allowShutdown=False,
                 notify_events={
                   'exception': 1,
                   'successToFailure': 1,
                   'failureToSuccess': 1,
                 })

{% raw %}
template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
<p> Build link <a href="{{ build_url }}">here</a>
<p><b> -- The Buildbot</b></p>
'''
{% endraw %}

mn = reporters.MailNotifier(fromaddr="buildbot@opencast.org",
                            sendToInterestedUsers=False,
                            mode=('change', 'failing', 'problem', 'warnings', 'exception'),
                            extraRecipients=["{{ mail_to }}"],
                            messageFormatter=reporters.MessageFormatter(
                                template=template, template_type='html',
                                wantProperties=True, wantSteps=True))

gh = reporters.GitHubStatusPush(token="{{ github_token }}")

#IRC bot has no auth, and basic things cause massive stack traces :(
c['services'] = [mn, gh]#, irc]

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Opencast"
c['titleURL'] = "https://github.com/opencast/opencast"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://{{ inventory_hostname }}/{{buildbot_url}}"

# minimalistic config to activate new web UI
c['www'] = dict(port={{ buildbot_port }},
                plugins=dict(waterfall_view={}, console_view={}),
                auth=util.GitHubAuth("{{ github_client_id }}", "{{ github_client_secret }}", apiVersion=4, getTeamsMembership=True),
                authz=util.Authz(
                        allowRules=[
                            util.AnyControlEndpointMatcher(role="Committers")
                        ],
                        roleMatchers=[
                            util.RolesFromGroups(groupPrefix='opencast/')
                        ]
                      ),
                change_hook_auth=[strcred.makeChecker(file:changehook.passwd")],
                change_hook_dialects={
                  'github': {
                    'secret': "{{ github_hook_secret }}",
                    'strict': True,
                  }
                })

c['logCompressionMethod'] = 'gz'
#Don't set the settings below - they lead to log truncation
#c['logMaxSize'] = 1024*1024 # 1M
#c['logMaxTailSize'] = 32768
c['logEncoding'] = 'utf-8'
#Turn off usage data collection
c['buildbotNetUsageData'] = None

#Clean up the database - note that this does *not* clean up the filesystem!
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=datetime.timedelta(weeks=4),
    hour=12,
    dayOfWeek=6
)]

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
