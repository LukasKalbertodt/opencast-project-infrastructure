# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import *
import copy
import os.path
import datetime

import builders
import build
import debs
import markdown
import reports
import rpms
import schedulers

c = BuildmasterConfig = {}

#The branches you want to configure builders for
#branch is the total git branch name
#pom is the pom version as a string, only this file
#debsVersion is the debian packaging branch to package with, this file and debs
#dists are the distributions built by this branch, only this file
branches = {
  'Develop': {
    'branch': 'develop',
    'pom': '6',
    'debsVersion': '6.x'
  }, '5.x': {
    'branch': 'r/5.x',
    'pom': '5',
    'debsVersion': '5.x',
  }, '4.x': {
    'branch': 'r/4.x',
    'pom': '4.0',
    'debsVersion': '4.x',
  }, '3.x': {
    'branch': 'r/3.x',
    'pom': '3.0',
    'debsVersion': '3.x',
  },
}

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
{% for worker in groups['workers'] %}
  #Worker {{ worker }}

  #Setting password=None here causes the latent worker to autogenerate a random password and transmit it via env variables!
  worker.DockerLatentWorker("{{ hostvars[worker]['name'] }}", password=None,
                docker_host='tcp://localhost:{{ (hostvars[worker]['id'] + 2375) }}',
{% if hostvars[worker]['docker_base'] == 'debian' %}
                image='greglogan/ocqa-deb9-worker',
{% elif hostvars[worker]['docker_base'] == 'centos' %}
                image='greglogan/ocqa-cent7-worker',
{% endif %}
                volumes=['{{ buildbot_base }}/ssh:/builder/.ssh', '{{ buildbot_base }}/m2:/builder/m2'],
                masterFQDN="localhost:9989",
                hostconfig={ "network_mode": "host" }, #Host mode needed to use the ssh-forwarded tunnel
                autopull=True,
                alwaysPull=True,
                followStartupLogs=True,
                max_builds={{ hostvars[worker]['maxbuilds'] | default('1') }}),
{% endfor %}
]

workers = [
{% for worker in groups['workers'] %}
  "{{ hostvars[worker]['name'] }}",
{% endfor %}
]

deb_workers = [
{% for worker in groups['workers'] %}
{% if hostvars[worker]['docker_base'] == 'debian' %}
  "{{ hostvars[worker]['name'] }}",
{% endif %}
{% endfor %}
]

rpm_workers = [
{% for worker in groups['workers'] %}
{% if hostvars[worker]['docker_base'] == 'centos' %}
  "{{ hostvars[worker]['name'] }}",
{% endif %}
{% endfor %}
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

{% if enable_polling %}
repo = changes.GitPoller(repourl="{{ source_repo_url }}",
                              branches=True,
                              pollinterval={{ poll_interval }},
                              buildPushesWithNoCommits=True)

pull_requests = changes.GitHubPullrequestPoller(
                              owner="{{ source_pr_owner }}",
                              repo="{{ source_pr_slug }}",
                              pollAtLaunch=True,
                              pollInterval={{ poll_interval }},
                              repository_type="git",
                              token="{{ github_token }}",
                              magic_link=True)

c['change_source'] = [ repo, pull_requests ]
{% else %}
#We're using a webhook, so other change sources are not needed
c['change_source'] = []
{% endif %}

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

c['schedulers'] = []
c['schedulers'].extend([schedulers.getPullRequestSchedulers()])

for pretty_branch_name in branches:
  git_branch_name = branches[pretty_branch_name]['branch']
  c['schedulers'].extend(schedulers.getSchedulers(pretty_branch_name, git_branch_name))


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

c['builders'] = []
c['builders'].extend(builders.getPullRequestBuilder(workers))

for pretty_branch_name in branches:
  git_branch_name = branches[pretty_branch_name]['branch']
  debs_version = branches[pretty_branch_name]['debsVersion']
  c['builders'].extend(builders.getBuildersForBranch(deb_workers, rpm_workers, pretty_branch_name, git_branch_name, debs_version))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

irc = reporters.IRC("irc.freenode.net", "oc-buildbot",
                 channels=["#opencast"],
                 allowForce=False,
                 allowShutdown=False,
                 notify_events={
                   'exception': 1,
                   'successToFailure': 1,
                   'failureToSuccess': 1,
                 })

{% raw %}
template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
<p> Build link <a href="{{ build_url }}">here</a>
<p><b> -- The Buildbot</b></p>
'''
{% endraw %}

mn = reporters.MailNotifier(fromaddr="buildbot@opencast.org",
                            sendToInterestedUsers=False,
                            mode=('change', 'failing', 'problem', 'warnings', 'exception'),
                            extraRecipients=["{{ mail_to }}"],
                            messageFormatter=reporters.MessageFormatter(
                                template=template, template_type='html',
                                wantProperties=True, wantSteps=True))

gh = reporters.GitHubStatusPush(token="{{ github_token }}",
                                startDescription="Building...",
                                endDescription="Build done")

#IRC bot has no auth, and basic things cause massive stack traces :(
c['services'] = [mn, gh]#, irc]

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Opencast"
c['titleURL'] = "https://github.com/opencast/opencast"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://{{ inventory_hostname }}/{{buildbot_url}}"

from twisted.cred import strcred
# minimalistic config to activate new web UI
c['www'] = dict(port={{ buildbot_port }},
                plugins=dict(waterfall_view={}, console_view={}),
                auth=util.GitHubAuth("{{ github_client_id }}", "{{ github_client_secret }}", apiVersion=4, getTeamsMembership=True),
                authz=util.Authz(
                        allowRules=[
                            util.AnyControlEndpointMatcher(role="Committers")
                        ],
                        roleMatchers=[
                            util.RolesFromGroups(groupPrefix='opencast/')
                        ]
                      ),
                change_hook_auth=[strcred.makeChecker("file:changehook.passwd")],
                change_hook_dialects={
                  'github': {
                    'secret': "{{ github_hook_secret }}",
                    'strict': True,
                  }
                })

c['logCompressionMethod'] = 'gz'
#Don't set the settings below - they lead to log truncation
#c['logMaxSize'] = 1024*1024 # 1M
#c['logMaxTailSize'] = 32768
c['logEncoding'] = 'utf-8'
#Turn off usage data collection
c['buildbotNetUsageData'] = None

#The path below is relative to the internal root of the master's docker image.  Do not change this.
c['secretsProviders'] = [secrets.SecretInAFile(dirname="/var/lib/buildbot/secrets")]

#Clean up the database - note that this does *not* clean up the filesystem!
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=datetime.timedelta(weeks=4),
    hour=12,
    dayOfWeek=6
)]

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : os.environ.get("BUILDBOT_DB_URL", "sqlite://").format(**os.environ),
}
