# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import *
import copy
import os.path
import datetime

c = BuildmasterConfig = {}

#The branches you want to configure builders for
#branch is the total git branch name
#pom is the pom version as a string
#dists are the distributions built by this branch
branches = {
  'Develop': {
    'branch': 'develop',
    'pom': '6',
    'debsVersion': '6.x',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'migration', 'presentation', 'worker' ]
  }, '5.x': {
    'branch': 'develop',
    'pom': '5',
    'debsVersion': '5.x',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'migration', 'presentation', 'worker' ]
  }, '4.x': {
    'branch': 'r/4.x',
    'pom': '4.0',
    'debsVersion': '4.x',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  }, '3.x': {
    'branch': 'r/3.x',
    'pom': '3.0',
    'debsVersion': '3.x',
    'dists': [ 'admin', 'adminpresentation', 'adminworker', 'allinone', 'ingest', 'presentation', 'worker' ]
  },
}

build_lock = util.WorkerLock("worker_builds", maxCount=3)

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = [
{% for worker in groups['workers'] %}
  #Worker {{ worker }}

  #Setting password=None here causes the latent worker to autogenerate a random password and transmit it via env variables!
  worker.DockerLatentWorker("{{ hostvars[worker]['name'] }}", password=None,
                docker_host='tcp://localhost:{{ (hostvars[worker]['id'] + 2375) }}',
                image='greglogan/ocqa-deb9-worker',
                volumes=['{{ buildbot_base }}/ssh:/buildbot/.ssh', '{{ buildbot_base }}/m2:/buildbot/m2'],
                masterFQDN="localhost:9989",
                hostconfig={ "network_mode": "host" }, #Host mode needed to use the ssh-forwarded tunnel
                autopull=True,
                alwaysPull=True,
                followStartupLogs=True,
                max_builds={{ hostvars[worker]['maxbuilds'] | default('1') }}),
{% endfor %}
]

workers = [
{% for worker in groups['workers'] %}
  "{{ hostvars[worker]['name'] }}",
{% endfor %}
]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

{% if enable_polling %}
repo = changes.GitPoller(repourl="{{ source_repo_url }}",
                              branches=True,
                              pollinterval={{ poll_interval }},
                              buildPushesWithNoCommits=True)

pull_requests = changes.GitHubPullrequestPoller(
                              owner="{{ source_pr_owner }}",
                              repo="{{ source_pr_slug }}",
                              pollAtLaunch=True,
                              pollInterval={{ poll_interval }},
                              repository_type="git",
                              token="{{ github_token }}",
                              magic_link=True)

c['change_source'] = [repo, pull_requests]
{% else %}
#We're using a webhook, so other change sources are not needed
c['change_source'] = []
{% endif %}

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

pullScheduler = schedulers.AnyBranchScheduler(name="Pull Requests",
                                                treeStableTimer={{ stability_limit }}, #NB: Do not make this a string, a horribly unclear error occurs and nothing works for this scheduler...
                                                builderNames=["Pull Request Build"],
                                                change_filter=util.ChangeFilter(category="pull"))

c['schedulers'] = [pullScheduler]

for branchName in branches:
  branch = branches[branchName]
  commits_branch = schedulers.AnyBranchScheduler(name=branchName + " Commits",
                                                  change_filter=util.ChangeFilter(category=None, branch_re=branch['branch']),
                                                  treeStableTimer={{ stability_limit }}, #NB: Do not make this a string, a horribly unclear error occurs and nothing works for this scheduler...
                                                  builderNames=[branchName + " Build"])

  nightly_branch = schedulers.Nightly(name=branchName + ' Nightly',
                                     change_filter=util.ChangeFilter(category=None, branch_re=branch['branch']),
                                     hour=3, onlyIfChanged=False,
                                     builderNames=[branchName + " Nightly"])

  reports_branch = schedulers.Triggerable(name=branchName + ' Reports',
                                       builderNames=[branchName + " Reports"])

  javadocs_branch = schedulers.Triggerable(name=branchName + ' Javadocs',
                                       builderNames=[branchName + " Javadocs"])

  markdown_branch = schedulers.Triggerable(name=branchName + ' Markdown docs',
                                       builderNames=[branchName + " Markdown docs"])

  deb_packaging_branch = schedulers.Triggerable(name=branchName + ' Debian Packaging',
                                       builderNames=[branchName + " Debian Packaging"])

  rpm_packaging_branch = schedulers.Triggerable(name=branchName + ' RPM Packaging',
                                       builderNames=[branchName + " RPM Packaging"])

  forceScheduler = schedulers.ForceScheduler(name="ForceBuildCommits" + branchName[0],
                                           buttonName="Force Build",
                                           label="Force Build Settings",
                                           builderNames=[branchName + " Build", branchName + " Nightly"],

                                           codebases=[
                                               util.CodebaseParameter(
                                                   "",
                                                   label="Main repository",
                                                   # will generate a combo box
                                                   branch=util.FixedParameter(
                                                     name="branch",
                                                     default=branches[branchName]['branch'],
                                                   ),
                                                   # will generate nothing in the form, but revision, repository,
                                                   # and project are needed by buildbot scheduling system so we
                                                   # need to pass a value ("")
                                                   revision=util.FixedParameter(name="revision", default="HEAD"),
                                                   repository=util.FixedParameter(name="repository", default="{{ source_repo_url }}"),
                                                   project=util.FixedParameter(name="project", default=""),
                                               ),
                                           ],

                                           # will generate a text input
                                           reason=util.StringParameter(name="reason", label="Reason:", required=False, size=80, default=""),

                                           # in case you don't require authentication this will display
                                           # input for user to type his name
                                           username=util.UserNameParameter(label="your name:", size=80),
                                           properties=[])

  c['schedulers'].extend([commits_branch, nightly_branch, forceScheduler, reports_branch, javadocs_branch, markdown_branch, deb_packaging_branch, rpm_packaging_branch])


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

checkout = steps.GitHub(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh',
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout")

prep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'clean', '-fdx'],
                  logfile='clean'),
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', '-Dmaven.repo.remote=http://{{ inventory_hostname }}/nexus', 'dependency:go-offline', '-fn'],
                  logfile='deps')
              ],
              haltOnFailure=True, flunkOnFailure=True, name="Build Prep")

build = steps.ShellCommand(
              command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', '-Dmaven.repo.remote=http://{{ inventory_hostname }}/nexus', 'clean', 'install'],
              haltOnFailure=True, flunkOnFailure=True, name="Build")

prep_master = steps.MasterShellCommand(
                     command=['mkdir', '-p',
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}")),
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}/reports")),
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}/debs")),
                       util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}/rpms")),
                       util.Interpolate(os.path.normpath("{{ deployed_reports_symlink_base }}"))],
                     name="Prep relevant directories on buildmaster")

fix_owner = steps.MasterShellCommand(
                   command=['chown', '-R',
                     '{{ getent_passwd['buildbot'][1] }}:{{ getent_passwd['buildbot'][2] }}',
                     util.Interpolate(os.path.normpath("{{ artifacts_dist_base }}"))],
                   name="Fixing ownership of directories we just created")

prep_PR_master = steps.MasterShellCommand(
                     command=['mkdir', '-p',
                       util.Interpolate(os.path.normpath("{{ deployed_PR_coverage }}"))],
                     name="Prep relevant directories on buildmaster")

#Note: We're using a string here because using the array disables shell globbing!  This applies to the scp steps as well.
uploadTarballs = steps.ShellCommand(
                        command=util.Interpolate("scp build/*.tar.gz {{ buildbot_scp_builds_put }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload build to buildmaster")

cobertura = steps.ShellCommand(
                command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', '-Dmaven.repo.remote=http://{{ inventory_hostname }}/nexus', 'cobertura:cobertura'],
                haltOnFailure=True, flunkOnFailure=True, name="Build Cobertura report")

uploadCobertura = steps.ShellCommand(
                        command=util.Interpolate("scp -r target/site/cobertura {{ buildbot_scp_coverage }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload code coverage report to buildmaster")

uploadPRCobertura = steps.ShellCommand(
                        command=util.Interpolate("scp -r target/site/cobertura {{ buildbot_scp_PR_coverage }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload code coverage report to buildmaster")

#TODO: Note: steps need updating
javadocs = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['npm', 'install'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='npm_install'),
                util.ShellArg(command=['node_modules/grunt/bin/grunt'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='grunt'),
              ], workdir="docs/guides", name="Build Markdown docs", haltOnFailure=True, flunkOnFailure=True)

#TODO: Note: source of files here is probably incorrect
uploadJavadocs = steps.ShellCommand(
                        command=util.Interpolate("scp -r target/site/* {{ buildbot_scp_javadocs }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload Javadocs docs to buildmaster")

markdown = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['npm', 'install'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='npm_install'),
                util.ShellArg(command=['node_modules/grunt/bin/grunt'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='grunt'),
              ], workdir="docs/guides", name="Build Markdown docs", haltOnFailure=True, flunkOnFailure=True)

uploadMarkdown = steps.ShellCommand(
                        command=util.Interpolate("scp -r target/site/* {{ buildbot_scp_markdown }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload Markdown docs to buildmaster")

site = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', '-Dmaven.repo.remote=http://{{ inventory_hostname }}/nexus', 'install'],
                  logfile='build', flunkOnFailure=True, haltOnFailure=True),
                util.ShellArg(command=['mvn', '-B', '-V', '-Dmaven.repo.local=./.m2', '-Dmaven.repo.remote=http://{{ inventory_hostname }}/nexus', 'site', 'site:stage', util.Interpolate('-DstagingDirectory=/buildbot/%(prop:parent_fragment)s')],
                  logfile='site', flunkOnFailure=True, haltOnFailure=True)
              ],
              haltOnFailure=True, flunkOnFailure=True, name="Build site report")

uploadSite = steps.ShellCommand(
                        command=util.Interpolate("scp -r /buildbot/%(prop:parent_fragment)s {{ buildbot_scp_reports }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload site report to buildmaster")

#Updating the symlink
updateSite = steps.MasterShellCommand(
                       command=util.Interpolate("rm -f {{ deployed_reports_symlink }} && ln -s {{ deployed_reports }} {{ deployed_reports_symlink }} && ln -s {{ deployed_javadocs }} {{ deployed_javadocs_symlink }}"),
                       name="Deploy Reports")

clean = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'clean', '-fdx'],
                  logfile='git'),
              ],
              haltOnFailure=True, flunkOnFailure=True, name="Cleanup")

for branchName in branches:
  trigger_reports = steps.Trigger(schedulerNames=[branchName + " Reports"],
                                  waitForFinish=False, name="Trigger " + branchName + " reports",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_debs = steps.Trigger(schedulerNames=[branchName + " Debian Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " Debian Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_rpms = steps.Trigger(schedulerNames=[branchName + " RPM Packaging"],
                                  waitForFinish=False, name="Trigger " + branchName + " RPM Packaging",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_javadocs = steps.Trigger(schedulerNames=[branchName + " Javadocs"],
                                  waitForFinish=False, name="Trigger " + branchName + " Javadocs",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  trigger_markdown = steps.Trigger(schedulerNames=[branchName + " Markdown Docs"],
                                  waitForFinish=False, name="Trigger " + branchName + " Markdown Docs",
                                  set_properties={"parent_build" : util.Property("buildnumber"), "parent_revision" : util.Property("got_revision"),
                                                  "branch" : util.Property("branch"), "branch_pretty" : util.Property("branch_pretty"),
                                                  "build_timestamp" : util.Property("build_timestamp")})

  branches[branchName]['triggers'] = {'reports': trigger_reports, 'debs': trigger_debs, 'rpms': trigger_rpms, 'javadocs': trigger_javadocs, 'markdown': trigger_markdown}


debChecker = steps.SetPropertyFromCommand(command="[ -d .git ] && echo True || echo False",
                                          property="alreadyCloned", name="Checking if this is a fresh clone")

def wasCloned(step):
  if step.getProperty("alreadyCloned") == "True":
    return True
  else:
    return False

def wasNotCloned(step):
  return not wasCloned(step)

def hideIfAlreadyCloned(results, step):
  return wasCloned(step)

def hideIfNotAlreadyCloned(results, step):
  return wasNotCloned(step)

debsClone = steps.ShellCommand(
                       command=['git', 'clone', "{{ source_deb_repo_url }}", '--branch', util.Property('branch'), './'],
                         flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasNotCloned, hideStepIf=hideIfAlreadyCloned, name="Cloning debian packaging configs")

debsUpdate = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['git', 'fetch'],
                  flunkOnFailure=True, logfile='fetch'),
                util.ShellArg(command=['git', 'reset', '--hard', util.Interpolate('origin/%(prop:branch)s')], #We use reset here to get rid of other entries in the changelog
                  flunkOnFailure=True, logfile='checkout')
              ], workdir="build", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, doStepIf=wasCloned, hideStepIf=hideIfNotAlreadyCloned, name="Resetting debian packaging configs")

debsVersion = steps.SetPropertyFromCommand(command="git rev-parse HEAD", property="deb_script_rev", flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True,
                                   workdir="build", name="Get Debian script revision")

debsClean = steps.ShellCommand(
                       command=['rm', '-rf', 'binaries', 'outputs'], workdir="build",
                       flunkOnFailure=False, warnOnFailure=True, name="Cleaning debian packaging directories")

debsPrep = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['dch', '--newversion', util.Interpolate('%(prop:debs_package_version)s-%(prop:parent_build)s'), '-b', '-D', 'unstable', '-u', 'low', '--empty', util.Interpolate('Build revision %(prop:parent_revision)s, built with %(prop:deb_script_rev)s scripts')],
                  flunkOnFailure=True, warnOnFailure=True, logfile='dch'),
                util.ShellArg(command=['git', 'config', 'user.email', 'buildbot@opencast.org'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='email'),
                util.ShellArg(command=['git', 'config', 'user.name', 'Buildbot'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='authorname'),
                util.ShellArg(command=['git', 'commit', '-am', 'Automated commit prior to build'],
                  flunkOnFailure=True, warnOnFailure=True, logfile='commit')
              ], workdir="build/opencast", name="Prepping Debs", haltOnFailure=True, flunkOnFailure=True)

debsFetch = steps.ShellSequence(
              commands=[
                util.ShellArg(command=['mkdir', '-p', util.Interpolate('binaries/%(prop:debs_package_version)s')],
                  haltOnFailure=True, flunkOnFailure=True, logfile="prep"),
                util.ShellArg(command=util.Interpolate("scp {{ buildbot_scp_builds_get }} binaries/%(prop:debs_package_version)s/"),
                  haltOnFailure=True, flunkOnFailure=True, logfile="download")
              ], name="Fetching built artifacts from buildmaster", haltOnFailure=True, flunkOnFailure=True)


debsBuild = steps.ShellSequence(
              commands=[
                util.ShellArg(command=util.Interpolate('echo "source library.sh\ndoOpencast %(prop:debs_package_version)s %(prop:branch)s %(prop:parent_revision)s" | tee build.sh'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='write'),
                util.ShellArg(command=['bash', 'build.sh'],
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='build'),
                util.ShellArg(command=util.Interpolate('echo "Opencast version %(prop:parent_revision)s packaged with version %(prop:deb_script_rev)s" | tee outputs/%(prop:parent_revision)s/revision.txt'),
                       flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, logfile='revision')
              ], workdir="build", name="Build debs", haltOnFailure=True, flunkOnFailure=True)

debsUpload = steps.ShellCommand(
                        command=util.Interpolate("scp -r outputs/%(prop:parent_revision)s/* {{ buildbot_scp_debs }}"),
                        haltOnFailure=True, flunkOnFailure=True, name="Upload debs to buildmaster")


f_pr_build = util.BuildFactory()
f_pr_build.addStep(checkout)
f_pr_build.addStep(prep)
f_pr_build.addStep(build)
f_pr_build.addStep(cobertura)
f_pr_build.addStep(prep_PR_master)
f_pr_build.addStep(uploadPRCobertura)

def create_branch_builders(branchname):

  f_build = util.BuildFactory()
  #This is needed because the nightly schedulers don't set the branch name for some reason...
  f_build.addStep(steps.SetProperty(property="branch", value=branches[branchname]['branch'], name="Set regular branch name"))
  f_build.addStep(steps.SetProperty(property="branch_pretty", value=branchname, name="Set pretty branch name"))
  f_build.addStep(steps.SetPropertyFromCommand(command="date -u +%FT%H-%M-%S", property="build_timestamp",
                                   flunkOnFailure=True, warnOnFailure=True, haltOnFailure=True, name="Get build timestamp"))
  f_build.addStep(steps.Git(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh', branch=branches[branchname]['branch'],
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout"))
  f_build.addStep(prep)
  f_build.addStep(build)
  f_build.addStep(cobertura)
  f_build.addStep(prep_master)
  f_build.addStep(fix_owner)
  f_build.addStep(uploadTarballs)
  f_build.addStep(uploadCobertura)
  f_build.addStep(clean)

  f_reports = util.BuildFactory()
  f_reports.addStep(steps.Git(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh', branch=branches[branchname]['branch'],
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout"))
  f_reports.addStep(prep)
  f_reports.addStep(site)
  f_reports.addStep(uploadSite)
  f_reports.addStep(updateSite)
  f_reports.addStep(clean)

  f_javadocs = util.BuildFactory()
  f_javadocs.addStep(steps.Git(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh', branch=branches[branchname]['branch'],
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout"))
  f_javadocs.addStep(prep)
  f_javadocs.addStep(javadocs)
  f_javadocs.addStep(uploadJavadocs)
  f_javadocs.addStep(clean)

  f_markdown = util.BuildFactory()
  f_markdown.addStep(steps.Git(repourl="{{ source_repo_url }}",
                     mode='incremental', method='fresh', branch=branches[branchname]['branch'],
                     haltOnFailure=True, flunkOnFailure=True, name="Checkout"))
  f_markdown.addStep(prep)
  f_markdown.addStep(markdown)
  f_markdown.addStep(uploadMarkdown)
  f_markdown.addStep(clean)

  #We have some branch-specific steps that have to be built or fetched, do that first
  report_trigger_step = branches[branchname]['triggers']['reports']
  deb_trigger_step = branches[branchname]['triggers']['debs']
  rpm_trigger_step = branches[branchname]['triggers']['rpms']

  f_full_build = copy.deepcopy(f_build)
  f_full_build.addStep(report_trigger_step)
  f_full_build.addStep(deb_trigger_step)
  f_full_build.addStep(rpm_trigger_step)

  f_package_debs = util.BuildFactory()
  f_package_debs.addStep(steps.SetProperty(property="branch", value=branches[branchname]['branch'], name="Set regular branch name"))
  f_package_debs.addStep(steps.SetProperty(property="branch_pretty", value=branchname, name="Set pretty branch name"))
  f_package_debs.addStep(steps.SetProperty(property="debs_package_version", value=branches[branchname]['debsVersion'], name="Set Debian package version"))
  f_package_debs.addStep(debChecker)
  f_package_debs.addStep(debsClone)
  f_package_debs.addStep(debsUpdate)
  f_package_debs.addStep(debsVersion)
  f_package_debs.addStep(debsPrep)
  f_package_debs.addStep(debsFetch)
  f_package_debs.addStep(debsBuild)
  f_package_debs.addStep(debsUpload)
  f_package_debs.addStep(clean)

  f_package_rpms = util.BuildFactory()
  #TODO: Add steps to build the RPMs


  b_build = util.BuilderConfig(name=branchname + " Build",
        workernames=workers, locks=[build_lock.access('counting')],
        factory=f_build, collapseRequests=True)

  b_nightly = util.BuilderConfig(name=branchname + " Nightly",
        workernames=workers, locks=[build_lock.access('counting')],
        factory=f_full_build, collapseRequests=True)

  b_reports = util.BuilderConfig(name=branchname + " Reports",
        workernames=workers, locks=[build_lock.access('counting')],
        factory=f_reports, collapseRequests=True)

  b_javadocs = util.BuilderConfig(name=branchname + " Javadocs",
        workernames=workers, locks=[build_lock.access('counting')],
        factory=f_javadocs, collapseRequests=True)

  b_markdown = util.BuilderConfig(name=branchname + " Markdown Docs",
        workernames=workers, locks=[build_lock.access('counting')],
        factory=f_markdown, collapseRequests=True)

  b_package_debs = util.BuilderConfig(name=branchname + " Debian Packaging",
        workernames=workers, locks=[build_lock.access('counting')],
        factory=f_package_debs, collapseRequests=True)

  b_package_rpms = util.BuilderConfig(name=branchname + " RPM Packaging",
        workernames=workers, locks=[build_lock.access('counting')],
        factory=f_package_rpms, collapseRequests=True)

  return [ b_build, b_nightly, b_reports, b_javadocs, b_markdown, b_package_debs, b_package_rpms ]


b_pr = util.BuilderConfig(name="Pull Request Build",
      workernames=workers, locks=[build_lock.access('counting')],
      factory=f_pr_build, collapseRequests=True)

c['builders'] = [ b_pr ]
for branch in branches.keys():
  c['builders'].extend(create_branch_builders(branch))

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

irc = reporters.IRC("irc.freenode.net", "oc-buildbot",
                 channels=["#opencast"],
                 allowForce=False,
                 allowShutdown=False,
                 notify_events={
                   'exception': 1,
                   'successToFailure': 1,
                   'failureToSuccess': 1,
                 })

{% raw %}
template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
<p> Build link <a href="{{ build_url }}">here</a>
<p><b> -- The Buildbot</b></p>
'''
{% endraw %}

mn = reporters.MailNotifier(fromaddr="buildbot@opencast.org",
                            sendToInterestedUsers=False,
                            mode=('change', 'failing', 'problem', 'warnings', 'exception'),
                            extraRecipients=["{{ mail_to }}"],
                            messageFormatter=reporters.MessageFormatter(
                                template=template, template_type='html',
                                wantProperties=True, wantSteps=True))

gh = reporters.GitHubStatusPush(token="{{ github_token }}")

#IRC bot has no auth, and basic things cause massive stack traces :(
c['services'] = [mn, gh]#, irc]

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Opencast"
c['titleURL'] = "https://github.com/opencast/opencast"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://{{ inventory_hostname }}/{{buildbot_url}}"

from twisted.cred import strcred
# minimalistic config to activate new web UI
c['www'] = dict(port={{ buildbot_port }},
                plugins=dict(waterfall_view={}, console_view={}),
                auth=util.GitHubAuth("{{ github_client_id }}", "{{ github_client_secret }}", apiVersion=4, getTeamsMembership=True),
                authz=util.Authz(
                        allowRules=[
                            util.AnyControlEndpointMatcher(role="Committers")
                        ],
                        roleMatchers=[
                            util.RolesFromGroups(groupPrefix='opencast/')
                        ]
                      ),
                change_hook_auth=[strcred.makeChecker("file:changehook.passwd")],
                change_hook_dialects={
                  'github': {
                    'secret': "{{ github_hook_secret }}",
                    'strict': True,
                  }
                })

c['logCompressionMethod'] = 'gz'
#Don't set the settings below - they lead to log truncation
#c['logMaxSize'] = 1024*1024 # 1M
#c['logMaxTailSize'] = 32768
c['logEncoding'] = 'utf-8'
#Turn off usage data collection
c['buildbotNetUsageData'] = None

#Clean up the database - note that this does *not* clean up the filesystem!
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=datetime.timedelta(weeks=4),
    hour=12,
    dayOfWeek=6
)]

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : os.environ.get("BUILDBOT_DB_URL", "sqlite://").format(**os.environ),
}
